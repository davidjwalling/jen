#include "passphrase.h"
#include "base64.h"
#include "num.h"
#include "random.h"

const size_t passphrase_enc[] = {
 0x3df,  0xef, 0x1b7,  0x7b,  0x1b,  0x1d, 0x3f7, 0x15b,  0xd7, 0x1ab, 0x177, 0x1ad,  0x6b, 0x3ef,  0x7f,  0xad,
  0xff,  0x05,  0xaf, 0x16b,  0x0d, 0x16d, 0x1f7,  0x5b, 0x1ed,  0x07,  0xb5, 0x1df,  0x35,  0xbb,  0x17,  0xed,
  0x57, 0x17b,  0xaB, 0x1ff, 0x157,  0x5f, 0x37f,  0xd5, 0x1eb,  0xdb,  0x6f, 0x1f5,  0x3f,  0xf7, 0x15f,  0x0b,
  0xfd, 0x2ff, 0x1d7, 0x3bf, 0x175, 0x1fb,  0xb7, 0x1db,  0x7d,  0xdf, 0x1fd,  0x2f,  0xeb, 0x1b5,  0xbd,  0x75,
 0x1ef, 0x155,  0x2d, 0x15d, 0x1bd,  0xf5,  0x01,  0x1f, 0x1d5,  0x3b,  0x5d,  0xfb, 0x17d,  0x2b, 0x16f,  0xbf,
 0x3ff,  0x37, 0x1bb, 0x17f, 0x1af,  0x03,  0x0f,  0x77, 0x1bf, 0x1dd,  0x3d,  0x15,  0x55,  0x6d,  0xdd,     0
};

const size_t passphrase_distr[] = {
 70, 352, 205, 133, 510,  26, 366, 452, 312, 338, 197, 237, 196, 112,   4, 254,
110, 128,  24, 253, 489,  99,  51, 129,  74, 414, 231, 491, 149, 347, 450, 427,
283, 495, 223, 214, 484, 472, 479, 144, 324, 211,  21,  50, 136, 319, 188, 418,
  9, 115, 186,  15, 417, 466, 193, 180, 230, 458, 198,  72, 126, 238, 509, 435,
471,  59,   2, 215, 439, 337,  78, 372, 271, 203, 405, 174, 132, 453, 236, 234,
 34, 462, 191, 456,  87, 270, 263, 121, 123, 160,  13, 297, 444, 354,  97, 131,
476,  66, 457, 262, 369, 298, 321, 394, 464, 256, 163, 376, 336, 249, 240, 287,
 44, 245, 395,  89, 260,  58, 468, 182, 438,  40, 459, 497, 432, 302, 105, 502,
181, 222,  41, 168, 447, 364,  79,  68, 396, 385, 430, 406,  43,  11, 179, 290,
363, 461, 216, 378, 306,  69, 266, 362, 267, 246,  18, 368, 482, 125, 403,   8,
268, 219, 481,  12,  23, 508, 455, 433,  56, 322, 206, 274, 371, 143, 145, 217,
315, 443, 473, 134,  84, 477,  32, 257, 225, 209, 226,  33, 474, 392,  17, 401,
361, 333, 170, 335,  10, 421,  60, 172, 166, 232, 469, 139,  63, 275,  14, 422,
157, 282,  91, 280, 345, 158, 478, 357, 442,  28, 281, 251, 389, 311, 165,   1,
326, 393, 235, 155, 248, 164,  52, 210, 261, 370, 441, 278, 373,  37,  85, 241,
317, 390, 499, 490, 365, 493, 410, 329, 117, 445, 426, 399, 213, 293, 140, 208,
190, 265,  76,  20, 304, 511,   5, 332, 367, 408,  27, 314, 465, 506,  57, 360,
434, 119, 233, 185, 343, 411, 148, 284, 391, 340, 351, 449, 344, 171,  86, 446,
114, 501, 386, 103,  82,  39,  22, 420, 194, 111,  96, 159, 451,  25, 409, 277,
169, 127,  90, 296, 475, 440, 218, 470, 436, 388,  64, 331, 220, 102, 416,  93,
463, 505, 454, 425,  71, 146, 192, 104, 178, 224,  83,  47, 221,  80, 147, 201,
503, 199, 330, 177, 184, 291, 195, 356, 142, 308,  61, 334, 400, 404,  19, 485,
313,  36, 285, 100, 130, 242,  35, 301, 244, 460, 496,  73, 286,  92, 387, 276,
162,  94, 183,  55, 413, 167, 325, 113, 259, 305, 318, 492, 227, 419, 294, 428,
316, 429, 207, 243, 353, 384, 118,  67, 377, 273, 380, 328, 412, 348, 307,  95,
 54, 339, 448, 402, 431, 101,  38, 483, 202, 309, 250,   3, 269,  75, 154,  98,
349, 487, 151,   7, 423, 292, 152,  62, 342, 486,  49, 323, 379, 500, 374, 346,
150, 252, 320,  42, 272, 122, 258, 467, 228, 415, 175,  53, 382, 397,   0, 295,
116, 109, 120, 303, 310, 383, 173, 350, 494,  30, 488, 247, 239, 200, 138, 381,
 45,  77, 359, 341, 398, 288, 299, 229, 135, 137, 161, 141, 106, 204,  81, 255,
437,  88, 407, 504, 498, 358, 480,  31, 327, 264, 279, 507, 189, 424, 289, 355,
 16, 107, 176, 212, 187, 124,   6, 300, 153,  48,  46, 108, 375, 156,  65,  29
};

bool Passphrase::Encode(uint8_t* out, const char* in)
{
    return Encode((char*)out, (char*)in);
}

bool Passphrase::Encode(char* out, char* in)
{
    size_t erot, drot, j, ch, enc, bit;
    char* p;
    uint8_t bin[64] = { 0 };
    Random rand;
    Num R;
     R.putRandom(rand, 512);
    drot = ((R.bit( 16) ? 0x100 : 0) | (R.bit(107) ? 0x80 : 0) | (R.bit(176) ? 0x40 : 0)
        |   (R.bit(212) ?  0x20 : 0) | (R.bit(187) ? 0x10 : 0) | (R.bit(124) ? 0x08 : 0)
        |   (R.bit(  6) ?  0x04 : 0) | (R.bit(300) ? 0x02 : 0) | (R.bit(153) ? 0x01 : 0));
    erot = ((R.bit( 48) ?  0x40 : 0) | (R.bit( 46) ? 0x20 : 0) | (R.bit(108) ? 0x10 : 0)
        |   (R.bit(375) ?  0x08 : 0) | (R.bit(156) ? 0x04 : 0) | (R.bit( 65) ? 0x02 : 0) 
        |   (R.bit( 29) ? 0x01 : 0));
    for (p = in, j = 0, ch = *p++; ch && j < 496; ch = *p++) {
        if (ch < 32 || ch > 126)
            return false;
        ch -= 32;
        enc = passphrase_enc[(ch + erot) % 95];
        for (; enc && j < 496; enc >>= 1, j++) {
            bit = passphrase_distr[(j + drot) % 496];
            if (enc & 1)
                R.setBit(bit);
            else
                R.resetBit(bit);
        }
        if (j > 493)
            return false;
        bit = passphrase_distr[(j + drot) % 496];
        R.resetBit(bit);
        j++;
        bit = passphrase_distr[(j + drot) % 496];
        R.resetBit(bit);
        j++;
    }
    bit = passphrase_distr[(j + drot) % 496];
    R.resetBit(bit);
    size_t len = 64;
    R.bin(bin, len);
    base64enc((uint8_t*)out, bin, &len);
    return true;
}

bool Passphrase::Decode(uint8_t* out, char* in)
{
    return Decode((char*)out, (char*)in);
}

bool Passphrase::Decode(char* out, char* in)
{
    size_t erot, drot, j, ch, bit, bit0, bit1, bit2, enc, k;
    const size_t* p;
    uint8_t bin[66] = { 0 };
    char* q;
    Num R;
    j = strlen(in);
    if (j != 88)
        return false;
    base64dec(bin, (uint8_t*)in, &j);
    R.putBin(bin, 64);
    drot = ((R.bit(16) ? 0x100 : 0) | (R.bit(107) ? 0x80 : 0) | (R.bit(176) ? 0x40 : 0)
        | (R.bit(212) ? 0x20 : 0) | (R.bit(187) ? 0x10 : 0) | (R.bit(124) ? 0x08 : 0)
        | (R.bit(6) ? 0x04 : 0) | (R.bit(300) ? 0x02 : 0) | (R.bit(153) ? 0x01 : 0));
    erot = ((R.bit(48) ? 0x40 : 0) | (R.bit(46) ? 0x20 : 0) | (R.bit(108) ? 0x10 : 0)
        | (R.bit(375) ? 0x08 : 0) | (R.bit(156) ? 0x04 : 0) | (R.bit(65) ? 0x02 : 0)
        | (R.bit(29) ? 0x01 : 0));

    j = bit2 = bit1 = 0;
    bit = passphrase_distr[(j + drot) % 496];
    bit0 = R.bit(bit);
    j++;
    q = out;
    while (bit0 || bit1 || bit2) {
        for (enc = 0, k = 1; bit0 || bit1; j++, k <<= 1) {
            if (bit0)
                enc |= k;
            bit2 = bit1;
            bit1 = bit0;
            bit = passphrase_distr[(j + drot) % 496];
            bit0 = R.bit(bit);
        }
        bit2 = bit1;
        bit1 = bit0;
        bit = passphrase_distr[(j + drot) % 496];
        bit0 = R.bit(bit);
        j++;
        for (p = passphrase_enc; *p && *p != enc; p++);
        if (!(*p))
            return false;
        ch = ((p - passphrase_enc) + 190 - erot) % 95;
        *q++ = (char)ch + 32;
    }
    *q = 0;
    return true;
}
